'''
2. Написать два алгоритма нахождения i-го по счёту простого числа.
Без использования «Решета Эратосфена»;
Используя алгоритм «Решето Эратосфена»
'''

'''
Расчитывалось время работы двух алгоритмов:
- Решето Эратосфена
- Обычный перебор элементов
num - это i-й элемент последовательности простых чисел. Т.к. при увеличении последовательности натуральных
чисел количество простых чисел сокращается, то для определения длины последовательности натуральных чисел,
в которую попадет i-й элемент, умножаю num на 10 если i-й элемент меньше 2000-го и на 15, если больше.
'''

'''
Алгоритм с использование «Решета Эратосфена»
'''
import cProfile

def input_list(num):
    if num < 2000:
        n = num * 9
    else:
        n = num * 15
    ls = [0] * n
    for i in range(n):
        ls[i] = i
    return ls

def find_numbers(ls, n):
    ls[1] = 0
    m = 2
    while m < n:
        if ls[m] != 0:
            j = m * 2
            while j < n:
                ls[j] = 0
                j = j + m
        m += 1
    return ls

def out_list(ls):
    final_list = []
    for i in ls:
        if ls[i] != 0:
            final_list.append(ls[i])
    return final_list

def main():
    num = 10000
    a = input_list(num)
    b = find_numbers(a, num)
    c = out_list(b)
    print(c[num - 1])

cProfile.run('main()')

'''
Результат работы алгоритма, num = 10 000:

18770
         141237 function calls in 0.087 seconds

   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.003    0.003    0.087    0.087 <string>:1(<module>)
        1    0.003    0.003    0.003    0.003 main1.py:14(find_numbers)
        1    0.045    0.045    0.068    0.068 main1.py:26(out_list)
        1    0.012    0.012    0.012    0.012 main1.py:3(input_list)
        1    0.000    0.000    0.084    0.084 main1.py:33(main)
        1    0.000    0.000    0.087    0.087 {built-in method builtins.exec}
        1    0.000    0.000    0.000    0.000 {built-in method builtins.print}
   141229    0.023    0.000    0.023    0.000 {method 'append' of 'list' objects}
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
'''


'''
Алгоритм перебора элементов
'''
import cProfile

def input_list(num):
    if num < 2000:
        n = num * 9
    else:
        n = num * 15
    ls = [0] * n
    for i in range(n):
        ls[i] = i
    return ls

def find_numbers(ls, n):
    for i in range(2, n):
        for j in range(2, i - 1):
            if i % j == 0:
                ls[i] = 0
    ls[1] = 0
    return ls

def out_list(ls):
    final_list = []
    for i in ls:
        if ls[i] != 0:
            final_list.append(ls[i])
    return final_list

def main():
    num = 10000
    a = input_list(num)
    b = find_numbers(a, num)
    c = out_list(b)
    print(c[num - 1])

cProfile.run('main()')

'''
Результат работы алгоритма, num = 10 000:
18770
         141237 function calls in 3.200 seconds

   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.003    0.003    3.200    3.200 <string>:1(<module>)
        1    3.139    3.139    3.139    3.139 main2.py:14(find_numbers)
        1    0.032    0.032    0.047    0.047 main2.py:22(out_list)
        1    0.000    0.000    3.197    3.197 main2.py:29(main)
        1    0.011    0.011    0.011    0.011 main2.py:3(input_list)
        1    0.000    0.000    3.200    3.200 {built-in method builtins.exec}
        1    0.000    0.000    0.000    0.000 {built-in method builtins.print}
   141229    0.015    0.000    0.015    0.000 {method 'append' of 'list' objects}
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}

'''

'''
Очевидно, что скорость работы первого алгоритма намного быстрее
'''
